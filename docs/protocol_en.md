# Eman Protocol

**version:** 0.1
**date:** 21.10.2015

## process

all communication between services

event bus - eman service

If service wants listen or emit events, it connects to Eman.

## Abbr

- SV - service
- EM - eman
- `test` =>   - emit event

### handshake

1. **SV** connect => **EM**

   Service connecting to Eman WebSocket namespace "/communication"

   `ws://eman.host/communication`

2. **SV** `<= shake_who` **EM**

    Eman starting authorization

3. **SV** `shake_i_am =>` **EM**

    Service responding with auth credentials

    ```js
    {
        // service name
        name: "test_service",

        // secret key
        key: "secret_key"
    }
    ```

    ```js
    // TODO
    key  = md5(service.name + '.' + some_eman_salt);
    ```

3.1. If auth credentials invalid eman emit `shake_error` event and disconnect socket

```js
{
    error: {
        message: "Invalid key",
        code: 'invalid_key',
        status: 403
    }
}
```

4. **SV** `<= shake_id` **EM**

Eman generate uniq service id and emit to service

```js
{
    id: "...."
}
```

Service attach this id on every request or response event

5. **SV** `shake_ready =>` **EM**

Service make some startup actions and responds Eman about ready

6. **SV** `<= shake_online` **EM**

Eman reports Service that all done and Service in work

### Service init

1. After service got id (after `shake_id` stage), service subscribe on events from Eman

2. After every subscribe for event service must emit event `_service:api:request:subscribe`

```js
{
    name: 'messages.post'
}
```

3. If service unsubscribe event, must emit `_service:api:request:unsubscribe`

```js
{
    name: 'messages.post'
}
```


### Service disconnect

When service disconnect, Eman see socket disconnected - and clear all service data

### Service error dispatch

Service must subscribe on `_service:error` event

#### error event format

```js
{
	message: "human readable message",
	code: "error_code"
}
```

### Send Request, Got Response

For example, Service A want send message and got response, that message sent.

Service B can send messages.

### Abbr

- **SV_A** - Service A - client
- **SV_B** - Service B - worker
- **EM**   - Eman

### Process

1. **SV_A** `api_request =>` **EM**

    Service A emit event `api:request` with message data

    ```js
    {
        // name of event
        name: "messages.post",

        // uniq request id, generated by Service A
        request_id: "...",

        // uniq service id, from handshake 'shake_id' - stage
        sender_id: "...",

        // event data
        data: {
            from: "bob",
            to: "john",
            message: "hi!"
        }
    }
    ```

2. **EV** validate event data and emit event `messages.post` to all listeners

    (!) **EV** emits event `messages.post`, not `api:request`

    ```js
    {
        name: "messages.post",

        // same as on prev step
    }
    ```

3. **SV_B** `<= messages.post` **EV**

    Service B listen to `messages.post` events

    Service B send message from bob to john and send response to Eman

4. **SV_B** `api:response =>` **EV**

    response event

    ```js
    {
        name: "messages.post",

        // from request event
        request_id: "...",

        // from request event
        sender_id: "...",

        // Service B id  - from request
        recipient_id: "...",

        data: {
            // message id and all response data
            id: 1,
            // ...
        }
    }
    ```
4.1. If error happens, Service B send same `api:response`, but with error data:

```js
{
    name: "messages.post",
    request_id: "...",
    sender_id: "...",
    recipient_id: "...",
    error: {
        message: "Database query failed",

        code: "database_query_failed",

        // http-код  
        status: 500,

        // Список ошибок
        list: [
            {
                message: "Server Error"
            }
        ]
    }
}
```

5. **SV_A** `<= api:response` **EV**

    **SV_A** got response from Eman

    By uniq 'request_id' Service A can send message to callback or emit event internally
