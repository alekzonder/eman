# Protocol

**version:** 0.1

**date:** 21.10.2015

## Процесс


Все взаимодействия между сервисами происходят используя протокол WebSocket

Существует сервис для обмена событиями между сервисами - eman

Все сервисы, которые хотят получать события, подключаются к eman, слушают нужные события и отправляют события в ответ если это необходимо

Далее

- SV - Сервис
- EM - eman
- `test` =>   - означает отправку события


### установка соединения (handshake)

1. **SV** connect => **EM**

	Сервис коннетится к Eman к неймспесу /communication

	`ws://eman.host/communication`

2. **SV**  `<= shake_who`  **EM**

   **EV** запрашивает информацию о сервисе


3. **SV** `shake_i_am =>` **EM**

   Сервис отвечает с данными о себе

   ```js
   {
   		// имя сервиса
   		name: "test_service",

   		//
   		key: 'secret_key'

   }
   ```

	3.1. В случае неверных данных от сервиса eman отвечает событием `shake_error` и закрывает соединение

	```js
	{
		error: {
			message: "Invalid key",
			code: "invalid_key",
			status: 400
		}
	}
	```

4. **SV** `<= shake_id` **EM**

	eman отвечает сервису с уникальным id подключенного сервиса

	```js
	{
		id: "test_service.<timestamp>.<hash>"
	}
	```

	Сервис должен передавать этот id с запросами к другим сервисам и c ответам

5. **SV** `shake_ready =>` **EM**

	Сервис может произвести инициализацию и после этого ответить eman'у о готовности принимать события

6. **SV** `<= shake_online` **EM**

	eman сообщает сервису что все ок и он включен в работу


### Отправка запроса и получение ответа

Для примера у нас будет сервис A, который хочет отправить сообщение и получить ответ что оно отправлено.

Сервис B, который умеет отправлять сообщения

eman, который может обрабатывать события

- **SV_A** - Сервис А - клиент
- **SV_B** - Сервис B - исполнитель
- **EM** - eman


1. **SV_A** `api:request => ` **EM**

	Сервис А отправляет событие `api:request` с данными запроса

	```js
	{
		// название события
		name: "messages.post",

		// уникальный id запроса для этого сервиса
		request_id: "<...>",

		// id сервиса полученный при handshake
		sender_id: "<...>",

		// данные события
		data: {
			from: "<user_id>",
			to: "<channel_id",
			message: "Test message"
		}
	}
	```

	#### (!)
	```
	Пока не делаю

	**EM** должен
	либо отбалансировать событие на нужный сервис,
	либо отправить его в общий канал,
	либо и то и другое (???)
	```

2. **EV** проверяет данные события и отправляет событие `messages.post` всем слушателям

	**EV** отправляет уже событие `messages.post`, а не `api:request`

	```js
	{
		name: "messages.post",

		// ... все данные
		// аналогично первому шагу		
	}
	```

3. **SV_B** `<= messages.post` **EV**

	Сервис B подписан на события `messages.post`

	Получает такое событие делает что-то с этим сообщение, в нашем случае, отправляет сообщение в чат

	И отправляет событие с данными ответа в **EV**

4. **SV_B** `api:response =>` **EV**

	```js
	{
		name: "messages.post",

		// из события запроса
		request_id: "...",

		// из события запроса
		sender_id: "...",

		// id сервиса B (из handshake)
		recipient_id: "...",

		data: {
			// id добавленного сообщения
			id: "100500",
			message: "..."
		}
	}
	```

	4.1. В случае ошибки **SV_B** также отправляет `api:response`:

	```js
	{
		name: "messages.post",
		request_id: "...",
		sender_id: "...",
		recipient_id: "...",
		error: {
			message: "Database query failed",

			code: "database_query_failed",

			// http-код  
			status: 500,

			// Список ошибок
			list: [
				{
					message: "Ошибка сервера"
				}
			]
		}
	}
	```

5. **SV_A** `<= api:response` **EV**

	**SV_A**	получает ответ от **EV** из sender_id


6. **SV_A** получив ответ обрабатывает его и по request_id отправляет нужное событие в callback ...
